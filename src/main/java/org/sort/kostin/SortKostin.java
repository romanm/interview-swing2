package org.sort.kostin;


public class SortKostin {
	final static int ARRAY_SIZE = 20;
	public static void main(String[] args) {
		int c[] = new int[ARRAY_SIZE];
		for (int i = 0; i < ARRAY_SIZE; i++) {
			int random = (int) (Math.random()*ARRAY_SIZE);
			System.out.print(random+", ");
			c[i]=random;
		}
		System.out.println("\n-------sort-------");
		/* Внешний цикл постоянно сужает фрагмент массива,
		 * который будет рассматриваться, ведь после каждого прохода
		 * внутреннего цикла на последнем месте фрагмента будет
		 * оказываться нужный элемент (его не надо рассматривать снова).
		 */
		int[] a = c;
		for (int i = a.length - 1; i >= 2; i--) {
			/* В переменной sorted мы будем хранить признак того,
			 * отсортирован ли массив. Перед каждым проходом внутреннего
			 * цкла будем предполагать, что отсортирован, но если совершим
			 * хоть одну перестановку, то значит ещё не конца отсортирован.
			 * Этот приём, упрощающий сортировку, называется критерием Айверсона.
			 */
			boolean sorted = true;
			/* Во внутреннем цикле мы проходимся по фрагменту массива, который
			 * определяется внешним циклом. В этом фрагменте мы устанавливаем
			 * правильный порядок между соседними элементами, так попарно
			 * обрабатывая весь фрагмент.
			 */
			for (int j = 0; j < i; j++) {
				/* Если порядок соседних элементов не правильный, то их
				 * надо обменять местами. И запомнить, что была перестановка.
				 */
				if (a[j] > a[j+1]) {
					int temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
					sorted = false;
				}
			}
			/* Если массив отсортирован (т.е. не было ни одной перестановки
			 * во внутреннем цикле, значит можно прекращать работу внешнего
			 * цикла.
			 */
			if(sorted) {
				break;
			}
		}
		int[] aa = a;
		for (int integer : aa) {
			System.out.print(integer+", ");
		}
		System.out.println(" ");
	}
}
